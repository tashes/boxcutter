{
    "$schema": "https://ui.shadcn.com/schema/registry-item.json",
    "name": "boxcutter",
    "type": "registry:block",
    "title": "BoxCutter",
    "description": "Interactive PDF snipping surface with bookmarks, snippets, and outline extraction.",
    "registryDependencies": [
        "button",
        "badge",
        "card",
        "input",
        "slider"
    ],
    "dependencies": [
        "uuid@^11.1.0",
        "lucide-react@^0.525.0",
        "pdfjs-dist@^5.3.31"
    ],
    "files": [
        {
            "path": "registry/new-york/boxcutter/boxcutter.tsx",
            "type": "registry:component",
            "target": "components/boxcutter.tsx",
            "content": "\"use client\";\n// @ts-nocheck\n\nimport React, { useRef, useState, useEffect, useCallback } from \"react\";\nimport { v4 } from \"uuid\";\nimport {\n    Card,\n    CardContent,\n    CardHeader,\n    CardTitle,\n} from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { Input } from \"@/components/ui/input\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { deepEquals } from \"@/lib/boxcutter/utils/helpers\";\n\nconst BTNRADIUS = 8;\n\n// pdfjs is dynamically imported in effects to avoid SSR issues\nimport {\n    ArrowUpRight,\n    Bookmark,\n    BookmarkX,\n    ChevronLeft,\n    ChevronRight,\n    Download,\n    GitPullRequestArrow,\n    Menu,\n    Scissors,\n    Trash,\n} from \"lucide-react\";\n\nexport default function BoxCutter({\n    pdf = null,\n    page = undefined,\n    snippets = [],\n    onSnippetsChange = () => {},\n    toc = [],\n    onTOCChange = () => {},\n    onPageChange = () => {},\n    showSnippetsCollection = true,\n    onReady = undefined,\n}) {\n    const debug = (..._args) => {};\n    debug(\"mount\", {\n        pdfType: pdf && typeof pdf,\n        pdfByteLength: pdf && (pdf.byteLength || pdf.size || pdf.length || null),\n        page,\n        snippetsCount: Array.isArray(snippets) ? snippets.length : null,\n        tocCount: Array.isArray(toc) ? toc.length : null,\n    });\n    const canvasRef = useRef(null);\n    const overlayRef = useRef(null);\n\n    const [pdfData, setPdfData] = useState(pdf);\n    // Use controlled snippets from props; default to [] if undefined/null\n    const controlledSnippets = Array.isArray(snippets) ? snippets : [];\n    // Local TOC state (uncontrolled); sync outward via onTOCChange\n    const [contents, setContents] = useState(toc);\n    const [isContentsOpen, setIsContentsOpen] = useState(false);\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n    // Internal page state; syncs with optional controlled `page` prop\n    const [currentPage, setCurrentPage] = useState(1);\n    const [totalPages, setTotalPages] = useState(0);\n    const [scale, setScale] = useState(1.5);\n    const [activePointerType, setActivePointerType] = useState(null);\n    const [selection, setSelection] = useState({\n        startX: 0,\n        startY: 0,\n        endX: 0,\n        endY: 0,\n        isSelecting: false,\n    });\n    const [multiselection, setMultiselection] = useState({\n        selections: [],\n        isActive: false,\n    });\n    const [hoveredSelection, setHoveredSelection] = useState(null);\n    const [isSnippetsOpen, setIsSnippetsOpen] = useState(false);\n    // Track whether we've informed the parent that we're ready for interaction\n    const hasAnnouncedReady = useRef(false);\n\n    // Silence debug logs in production showcase\n\n    let renderSnippets = useCallback(() => {\n        if (!overlayRef.current) return;\n\n        const overlayCanvas = overlayRef.current;\n        const overlayContext = overlayCanvas.getContext(\"2d\");\n        if (!overlayContext) return;\n\n        // Clear overlay\n        overlayContext.clearRect(\n            0,\n            0,\n            overlayCanvas.width,\n            overlayCanvas.height,\n        );\n\n        // Draw existing snippets\n        const pageSnippets = controlledSnippets.filter(\n            (s) => s.pageNumber === currentPage,\n        );\n        pageSnippets.forEach((snippet, index) => {\n            const sx = snippet.x * scale;\n            const sy = snippet.y * scale;\n            const sw = snippet.width * scale;\n            const sh = snippet.height * scale;\n\n            const isHovered =\n                hoveredSelection?.type === \"single\" &&\n                hoveredSelection.id === snippet.id;\n\n            overlayContext.strokeStyle = \"#3b82f6\";\n            overlayContext.lineWidth = 2;\n            overlayContext.setLineDash([5, 5]);\n            overlayContext.strokeRect(sx, sy, sw, sh);\n\n            overlayContext.fillStyle = \"#3b82f6\";\n            overlayContext.font = \"12px Arial\";\n            overlayContext.fillText(`${index + 1}`, sx + 5, sy + 15);\n\n            if (isHovered) {\n                const btnRadius = BTNRADIUS;\n                const cx = sx + sw - btnRadius - 4;\n                const cy = sy + btnRadius + 4;\n\n                overlayContext.beginPath();\n                overlayContext.arc(cx, cy, btnRadius, 0, Math.PI * 2);\n                overlayContext.fillStyle = \"#ef4444\";\n                overlayContext.fill();\n\n                overlayContext.strokeStyle = \"#fff\";\n                overlayContext.lineWidth = 2;\n                overlayContext.setLineDash([]);\n                overlayContext.beginPath();\n                overlayContext.moveTo(cx - 4, cy - 4);\n                overlayContext.lineTo(cx + 4, cy + 4);\n                overlayContext.moveTo(cx + 4, cy - 4);\n                overlayContext.lineTo(cx - 4, cy + 4);\n                overlayContext.stroke();\n            }\n        });\n\n        // Draw multiselection rectangles\n        if (multiselection.isActive && multiselection.selections.length > 0) {\n            overlayContext.strokeStyle = \"#22c55e\";\n            overlayContext.lineWidth = 1;\n            overlayContext.setLineDash([3, 3]);\n\n            multiselection.selections.forEach((sel, i) => {\n                const x = Math.min(sel.startX, sel.endX);\n                const y = Math.min(sel.startY, sel.endY);\n                const width = Math.abs(sel.endX - sel.startX);\n                const height = Math.abs(sel.endY - sel.startY);\n                overlayContext.strokeRect(x, y, width, height);\n\n                const isHovered =\n                    hoveredSelection?.type === \"multi\" &&\n                    hoveredSelection.id === i;\n\n                if (isHovered) {\n                    const btnRadius = BTNRADIUS;\n                    const cx = x + width - btnRadius - 4;\n                    const cy = y + btnRadius + 4;\n\n                    overlayContext.beginPath();\n                    overlayContext.arc(cx, cy, btnRadius, 0, Math.PI * 2);\n                    overlayContext.fillStyle = \"#ef4444\";\n                    overlayContext.fill();\n\n                    overlayContext.strokeStyle = \"#fff\";\n                    overlayContext.lineWidth = 2;\n                    overlayContext.beginPath();\n                    overlayContext.moveTo(cx - 4, cy - 4);\n                    overlayContext.lineTo(cx + 4, cy + 4);\n                    overlayContext.moveTo(cx + 4, cy - 4);\n                    overlayContext.lineTo(cx - 4, cy + 4);\n                    overlayContext.stroke();\n                }\n            });\n        }\n\n        // Draw current selection\n        if (selection.isSelecting) {\n            const x = Math.min(selection.startX, selection.endX);\n            const y = Math.min(selection.startY, selection.endY);\n            const width = Math.abs(selection.endX - selection.startX);\n            const height = Math.abs(selection.endY - selection.startY);\n\n            overlayContext.strokeStyle = \"#ef4444\";\n            overlayContext.lineWidth = 2;\n            overlayContext.setLineDash([]);\n            overlayContext.strokeRect(x, y, width, height);\n\n            overlayContext.fillStyle = \"rgba(239, 68, 68, 0.1)\";\n            overlayContext.fillRect(x, y, width, height);\n        }\n    }, [\n        controlledSnippets,\n        currentPage,\n        selection,\n        multiselection,\n        scale,\n        hoveredSelection,\n    ]);\n\n    let extractSnippet = async () => {\n        if (!canvasRef.current || !selection.isSelecting) return;\n\n        const canvas = canvasRef.current;\n        const x = Math.min(selection.startX, selection.endX);\n        const y = Math.min(selection.startY, selection.endY);\n        const width = Math.abs(selection.endX - selection.startX);\n        const height = Math.abs(selection.endY - selection.startY);\n\n        // Create a new canvas for the snippet\n        const snippetCanvas = document.createElement(\"canvas\");\n        snippetCanvas.width = width;\n        snippetCanvas.height = height;\n        const snippetContext = snippetCanvas.getContext(\"2d\");\n\n        if (!snippetContext) return;\n\n        // Draw the selected area\n        snippetContext.drawImage(\n            canvas,\n            x,\n            y,\n            width,\n            height,\n            0,\n            0,\n            width,\n            height,\n        );\n\n        // Create new snippet\n        const newSnippet = {\n            id: `${v4()}`,\n            pageNumber: currentPage,\n            x: x / scale,\n            y: y / scale,\n            width: width / scale,\n            height: height / scale,\n            image: snippetCanvas.toDataURL(\"image/png\"),\n        };\n\n        onSnippetsChange([...controlledSnippets, newSnippet]);\n    };\n\n    let extractCombinedSnippet = async () => {\n        if (!canvasRef.current || multiselection.selections.length === 0)\n            return;\n\n        const canvas = canvasRef.current;\n\n        // Convert raw selections into usable rectangles\n        const rects = multiselection.selections.map((sel) => {\n            const x = Math.min(sel.startX, sel.endX);\n            const y = Math.min(sel.startY, sel.endY);\n            const width = Math.abs(sel.endX - sel.startX);\n            const height = Math.abs(sel.endY - sel.startY);\n            return { x, y, width, height };\n        });\n\n        // Get bounding box for all rectangles\n        const minX = Math.min(...rects.map((r) => r.x));\n        const minY = Math.min(...rects.map((r) => r.y));\n        const maxX = Math.max(...rects.map((r) => r.x + r.width));\n        const maxY = Math.max(...rects.map((r) => r.y + r.height));\n\n        const combinedWidth = maxX - minX;\n        const combinedHeight = maxY - minY;\n\n        // Create a new canvas for the combined snippet\n        const snippetCanvas = document.createElement(\"canvas\");\n        snippetCanvas.width = combinedWidth;\n        snippetCanvas.height = combinedHeight;\n        const snippetContext = snippetCanvas.getContext(\"2d\");\n\n        if (!snippetContext) return;\n\n        // Optional: white background\n        snippetContext.fillStyle = \"#ffffff\";\n        snippetContext.fillRect(0, 0, combinedWidth, combinedHeight);\n\n        // Draw each selection onto the combined canvas\n        rects.forEach((r) => {\n            const relativeX = r.x - minX;\n            const relativeY = r.y - minY;\n\n            snippetContext.drawImage(\n                canvas,\n                r.x,\n                r.y,\n                r.width,\n                r.height,\n                relativeX,\n                relativeY,\n                r.width,\n                r.height,\n            );\n        });\n\n        const newSnippet = {\n            id: `${v4()}`,\n            pageNumber: currentPage,\n            x: minX / scale,\n            y: minY / scale,\n            width: combinedWidth / scale,\n            height: combinedHeight / scale,\n            image: snippetCanvas.toDataURL(\"image/png\"),\n        };\n\n        onSnippetsChange([...controlledSnippets, newSnippet]);\n\n        setMultiselection({\n            selections: [],\n            isActive: false,\n        });\n    };\n\n    useEffect(() => {\n        const loadPDF = async () => {\n            debug(\"loadPDF: triggered\", {\n                pdfType: pdf && typeof pdf,\n                pdfByteLength:\n                    pdf && (pdf.byteLength || pdf.size || pdf.length || null),\n            });\n\n            if (!pdf) {\n                debug(\"loadPDF: no pdf provided (pending)\");\n                setPdfData(null);\n                setTotalPages(0);\n                setLoading(false);\n                setError(null);\n                return;\n            }\n\n            setLoading(true);\n            setError(null);\n            setPdfData(null);\n            try {\n                // Dynamically import pdfjs to avoid SSR/window issues\n                const { pdfjsLib } = await import(\n                    \"@/lib/boxcutter/utils/pdfjs\"\n                );\n                debug(\"loadPDF: pdfjs imported\", {\n                    workerSrc: pdfjsLib.GlobalWorkerOptions?.workerSrc,\n                });\n                const loadingTask = pdfjsLib.getDocument({\n                    data: pdf,\n                    useWorkerFetch: false,\n                    isEvalSupported: false,\n                    useSystemFonts: true,\n                    verbosity: 0,\n                });\n                const pdfDoc = await loadingTask.promise;\n                setPdfData(pdfDoc);\n                setTotalPages(pdfDoc.numPages);\n                // If controlled, start from provided page; otherwise default to 1\n                const initial = typeof page === \"number\" ? page : 1;\n                setCurrentPage(initial);\n                debug(\"loadPDF: loaded\", { numPages: pdfDoc.numPages, initial });\n            } catch (e) {\n                setError(e);\n                debug(\"loadPDF: error\", e);\n            } finally {\n                setLoading(false);\n                debug(\"loadPDF: finished\");\n            }\n        };\n\n        // Reset the ready flag when a new PDF is provided\n        hasAnnouncedReady.current = false;\n        loadPDF();\n    }, [pdf]);\n\n    // Track the active pdf.js render task across effect runs to avoid overlaps\n    const activeRenderTask = useRef(null);\n\n    useEffect(() => {\n        const loadPage = async () => {\n            setError(null);\n            try {\n                if (!pdfData || !canvasRef.current) {\n                    debug(\"render: bail (not ready)\", {\n                        hasPdfData: !!pdfData,\n                        hasCanvas: !!canvasRef.current,\n                    });\n                    return;\n                }\n\n                const canvas = canvasRef.current;\n                const context = canvas.getContext(\"2d\");\n                if (!context) throw new Error(\"No context found for canvas\");\n\n                // Clamp page using known numPages if necessary\n                const maxPages = pdfData?.numPages || totalPages || 0;\n                if (\n                    typeof currentPage !== \"number\" ||\n                    currentPage < 1 ||\n                    (maxPages && currentPage > maxPages)\n                ) {\n                    debug(\"render: bail (page out of range)\", {\n                        currentPage,\n                        maxPages,\n                    });\n                    return;\n                }\n\n                debug(\"render: getPage\", { currentPage, scale });\n                const page = await pdfData.getPage(currentPage);\n                const viewport = page.getViewport({ scale });\n\n                canvas.height = viewport.height;\n                canvas.width = viewport.width;\n\n                // Setup overlay canvas\n                if (overlayRef.current) {\n                    overlayRef.current.height = viewport.height;\n                    overlayRef.current.width = viewport.width;\n                }\n\n                const renderContext = {\n                    canvasContext: context,\n                    viewport: viewport,\n                };\n\n                // Ensure any previous render on this canvas is fully cancelled\n                if (activeRenderTask.current?.cancel) {\n                    try {\n                        activeRenderTask.current.cancel();\n                        await activeRenderTask.current.promise.catch(() => {});\n                    } catch {}\n                }\n\n                const task = page.render(renderContext);\n                activeRenderTask.current = task;\n                await task.promise;\n                debug(\"render: finished pageRender\", {\n                    width: viewport.width,\n                    height: viewport.height,\n                });\n                renderSnippets();\n\n                // Announce readiness once the first page has finished rendering\n                if (!hasAnnouncedReady.current) {\n                    hasAnnouncedReady.current = true;\n                    if (typeof onReady === \"function\") {\n                        // Defer to next frame to ensure DOM is painted\n                        const canvasEl = canvasRef.current;\n                        const overlayEl = overlayRef.current;\n                        const info = {\n                            totalPages,\n                            currentPage,\n                            scale,\n                            pageSize: {\n                                width: canvas.width,\n                                height: canvas.height,\n                            },\n                            canvas: canvasEl,\n                            overlay: overlayEl,\n                            jumpToPage: (target) => {\n                                const toNum = (val) => {\n                                    const n = typeof val === \"number\" ? val : parseInt(val, 10);\n                                    return Number.isFinite(n) ? n : 1;\n                                };\n                                const t = toNum(target);\n                                if (totalPages > 0 && t >= totalPages) setCurrentPage(totalPages);\n                                else if (t <= 1) setCurrentPage(1);\n                                else setCurrentPage(t);\n                            },\n                        };\n                        requestAnimationFrame(() => {\n                            debug(\"onReady: dispatch\", info);\n                            onReady(info);\n                        });\n                    }\n                }\n            } catch (e) {\n                if (e?.name !== \"RenderingCancelledException\") {\n                    setError(e);\n                    debug(\"render: error\", e);\n                }\n            }\n        };\n\n        loadPage();\n\n        // Cleanup render task when component or effect changes\n        return () => {\n            if (activeRenderTask.current?.cancel) {\n                try {\n                    activeRenderTask.current.cancel();\n                } catch {}\n            }\n        };\n    }, [pdfData, currentPage, scale, totalPages]);\n\n    useEffect(() => {\n        let animationFrameId = requestAnimationFrame(() => {\n            debug(\"raf: renderSnippets\");\n            renderSnippets();\n        });\n\n        return () => cancelAnimationFrame(animationFrameId);\n    }, [\n        controlledSnippets,\n        currentPage,\n        selection,\n        multiselection,\n        scale,\n        hoveredSelection,\n    ]);\n\n    useEffect(() => {\n        let handleKeyUp = () => {\n            if (\n                multiselection.isActive === true &&\n                multiselection.selections.length > 0\n            ) {\n                extractCombinedSnippet();\n            }\n        };\n\n        window.addEventListener(\"keyup\", handleKeyUp);\n\n        return () => {\n            window.removeEventListener(\"keyup\", handleKeyUp);\n        };\n    }, [multiselection]);\n\n    // Snippets are controlled; no internal state sync needed.\n\n    useEffect(() => {\n        if (!deepEquals(toc, contents)) {\n            debug(\"toc: sync outward\", { count: contents.length });\n            onTOCChange(contents);\n        }\n    }, [contents]);\n\n    useEffect(() => {\n        debug(\"page: change\", { currentPage });\n        onPageChange(currentPage);\n    }, [currentPage]);\n\n    // Keep internal page in sync with controlled `page` prop\n    useEffect(() => {\n        if (typeof page === \"number\") {\n            // Clamp to [1, totalPages] when totalPages is known (>0)\n            const max = totalPages && totalPages > 0 ? totalPages : undefined;\n            const next = Math.max(1, max ? Math.min(page, max) : page);\n            if (next !== currentPage) {\n                debug(\"page: sync from prop\", { prop: page, next, max });\n                setCurrentPage(next);\n            }\n        }\n    }, [page, totalPages]);\n\n    let handleExtractOutline = async (maxDepth = 1) => {\n        const outline = await pdfData.getOutline();\n        if (!outline) return [];\n\n        async function resolveItem(item, depth = 1) {\n            let pageNumber = null;\n            try {\n                let destArray = null;\n                if (Array.isArray(item.dest)) {\n                    destArray = item.dest;\n                } else if (typeof item.dest === \"string\") {\n                    const resolved = await pdfData.getDestination(item.dest);\n                    if (Array.isArray(resolved)) {\n                        destArray = resolved;\n                    }\n                }\n\n                if (destArray) {\n                    const [ref] = destArray;\n                    if (\n                        typeof ref === \"object\" &&\n                        ref !== null &&\n                        \"num\" in ref &&\n                        \"gen\" in ref\n                    ) {\n                        const pageIndex = await pdfData.getPageIndex(ref);\n                        pageNumber = pageIndex + 1;\n                    }\n                }\n            } catch (e) {\n                console.warn(\"Failed to resolve:\", item.title, e);\n            }\n\n            return {\n                title: item.title,\n                pageNumber,\n                children:\n                    depth < maxDepth && item.items\n                        ? await Promise.all(\n                              item.items.map((child) =>\n                                  resolveItem(child, depth + 1),\n                              ),\n                          )\n                        : [],\n            };\n        }\n\n        function flattenOutline(outline) {\n            const result = [];\n            const walk = (items) => {\n                for (const item of items) {\n                    result.push({\n                        title: item.title,\n                        pageNumber: item.pageNumber,\n                    });\n                    if (item.children) walk(item.children);\n                }\n            };\n            walk(outline);\n            return result;\n        }\n\n        const resolvedOutline = await Promise.all(\n            outline.map((item) => resolveItem(item, 1)),\n        );\n        const fullOutline = flattenOutline(resolvedOutline);\n        const pagedOutline = fullOutline\n            .filter((a) => a.pageNumber !== null)\n            .map((p) => ({\n                ...p,\n                id: v4(),\n                type: \"bookmark\",\n            }));\n\n        setContents(pagedOutline);\n    };\n\n    let handleScaleChange = (value) => {\n        setScale(value / 100);\n    };\n\n    let handlePreviousPage = () => {\n        if (currentPage <= 1) return;\n        setCurrentPage((pageNum) => pageNum - 1);\n    };\n\n    let handleNextPage = () => {\n        if (currentPage >= totalPages) return;\n        setCurrentPage((pageNum) => pageNum + 1);\n    };\n\n    let handleToggleSnippets = () => {\n        if (isContentsOpen === true) setIsContentsOpen(false);\n        setIsSnippetsOpen((snippetsOpenState) => !snippetsOpenState);\n    };\n\n    let handleToggleContents = () => {\n        if (isSnippetsOpen === true) setIsSnippetsOpen(false);\n        setIsContentsOpen((contentsOpenState) => !contentsOpenState);\n    };\n\n    let handleAddBookmark = (pageNumber) => {\n        setContents((prevContents) => {\n            const exists = prevContents.some(\n                (item) => item.pageNumber === pageNumber,\n            );\n            if (exists) return prevContents;\n\n            return [\n                ...prevContents,\n                {\n                    id: v4(),\n                    type: \"bookmark\",\n                    pageNumber,\n                    title: `Page ${pageNumber}`,\n                },\n            ].sort((a, b) => a.pageNumber - b.pageNumber);\n        });\n    };\n\n    let handleRemoveBookmark = (pageNumber) => {\n        setContents((prevContents) =>\n            prevContents.filter((item) => item.pageNumber !== pageNumber),\n        );\n    };\n\n    let handleBookmarkTitleChange = (index, title) => {\n        setContents([\n            ...contents.slice(0, index),\n            {\n                ...contents[index],\n                title,\n            },\n            ...contents.slice(index + 1),\n        ]);\n    };\n\n    let handleOpenPageNumber = (pageNumber) => {\n        const toNum = (val) => {\n            const n = typeof val === \"number\" ? val : parseInt(val, 10);\n            return Number.isFinite(n) ? n : 1;\n        };\n        const target = toNum(pageNumber);\n        if (totalPages > 0 && target >= totalPages) setCurrentPage(totalPages);\n        else if (target <= 1) setCurrentPage(1);\n        else setCurrentPage(target);\n    };\n\n    let handlePointerDown = (evt) => {\n        if (evt.pointerType === \"touch\") return;\n        if (!overlayRef.current) return;\n\n        const rect = overlayRef.current.getBoundingClientRect();\n        const x = evt.clientX - rect.left;\n        const y = evt.clientY - rect.top;\n\n        setActivePointerType(evt.pointerType);\n\n        setSelection({\n            startX: x,\n            startY: y,\n            endX: x,\n            endY: y,\n            isSelecting: true,\n        });\n\n        if (evt.pointerType === \"pen\") {\n            evt.preventDefault();\n        }\n    };\n\n    let handlePointerMove = (evt) => {\n        if (!overlayRef.current) return;\n\n        const rect = overlayRef.current.getBoundingClientRect();\n        const x = evt.clientX - rect.left;\n        const y = evt.clientY - rect.top;\n\n        // Adjust for scale\n        const scaledX = x / scale;\n        const scaledY = y / scale;\n\n        if (selection.isSelecting && evt.pointerType === activePointerType) {\n            setSelection((prev) => ({\n                ...prev,\n                endX: x,\n                endY: y,\n            }));\n            return;\n        }\n\n        let found = false;\n\n        // Hover over multiselections (screen-space)\n        multiselection.selections.forEach((sel, i) => {\n            const x1 = Math.min(sel.startX, sel.endX);\n            const y1 = Math.min(sel.startY, sel.endY);\n            const x2 = Math.max(sel.startX, sel.endX);\n            const y2 = Math.max(sel.startY, sel.endY);\n            if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {\n                setHoveredSelection({\n                    type: \"multi\",\n                    id: i,\n                    cx: x2 - 4 - BTNRADIUS,\n                    cy: y1 + 4 + BTNRADIUS,\n                });\n                found = true;\n            }\n        });\n\n        // Hover over snippets (PDF-space)\n        if (!found) {\n            const currentSnips = controlledSnippets.filter(\n                (s) => s.pageNumber === currentPage,\n            );\n            currentSnips.forEach((s) => {\n                const x1 = s.x;\n                const y1 = s.y;\n                const x2 = s.x + s.width;\n                const y2 = s.y + s.height;\n\n                if (\n                    scaledX >= x1 &&\n                    scaledX <= x2 &&\n                    scaledY >= y1 &&\n                    scaledY <= y2\n                ) {\n                    setHoveredSelection({\n                        type: \"single\",\n                        id: s.id,\n                        cx: x2 * scale - 4 - BTNRADIUS,\n                        cy: y1 * scale + 4 + BTNRADIUS,\n                    });\n                    found = true;\n                }\n            });\n        }\n\n        if (!found) {\n            setHoveredSelection(null);\n        }\n    };\n\n    let handlePointerUp = (evt) => {\n        if (hoveredSelection !== null) {\n            const rect = overlayRef.current.getBoundingClientRect();\n            const x = evt.clientX - rect.left;\n            const y = evt.clientY - rect.top;\n\n            const dx = x - hoveredSelection.cx;\n            const dy = y - hoveredSelection.cy;\n\n            if (Math.sqrt(dx * dx + dy * dy) <= BTNRADIUS) {\n                if (hoveredSelection.type === \"single\") {\n                    // Delete snippet\n                    const snipIndex = controlledSnippets.findIndex(\n                        (s) => s.id === hoveredSelection.id,\n                    );\n                    if (snipIndex !== -1) {\n                        onSnippetsChange([\n                            ...controlledSnippets.slice(0, snipIndex),\n                            ...controlledSnippets.slice(snipIndex + 1),\n                        ]);\n                    }\n                } else if (hoveredSelection.type === \"multi\") {\n                    // Delete multi-selection at index\n                    const newSelections = multiselection.selections.filter(\n                        (_, idx) => idx !== hoveredSelection.id,\n                    );\n                    setMultiselection({\n                        selections: newSelections,\n                        isActive: newSelections.length > 0,\n                    });\n                }\n            }\n        }\n\n        if (!selection.isSelecting || !activePointerType) return;\n        if (evt.pointerType !== activePointerType) return;\n\n        const newSel = {\n            startX: Math.min(selection.startX, selection.endX),\n            startY: Math.min(selection.startY, selection.endY),\n            endX: Math.max(selection.startX, selection.endX),\n            endY: Math.max(selection.startY, selection.endY),\n        };\n\n        const width = newSel.endX - newSel.startX;\n        const height = newSel.endY - newSel.startY;\n\n        if (width > 10 && height > 10) {\n            if (evt.shiftKey) {\n                // Append to multi-selection\n                const allSelections = [...multiselection.selections, newSel];\n\n                setMultiselection({\n                    selections: allSelections,\n                    isActive: true,\n                });\n            } else {\n                // Normal single selection\n                setSelection({ ...newSel, isSelecting: true });\n\n                setTimeout(() => {\n                    extractSnippet();\n                }, 0);\n            }\n        }\n\n        setSelection((prev) => ({ ...prev, isSelecting: false }));\n        setActivePointerType(null);\n    };\n\n    let handlePointerLeave = (evt) => {\n        if (selection.isSelecting && evt.pointerType === activePointerType) {\n            setSelection((prev) => ({ ...prev, isSelecting: false }));\n            setActivePointerType(null);\n        }\n        if (multiselection.isActive === true) {\n            setMultiselection({\n                selections: [],\n                isActive: false,\n            });\n        }\n        setHoveredSelection(null);\n    };\n\n    let handlePointerCancel = (evt) => {\n        if (selection.isSelecting && evt.pointerType === activePointerType) {\n            setSelection((prev) => ({ ...prev, isSelecting: false }));\n            setActivePointerType(null);\n        }\n        if (multiselection.isActive === true) {\n            setMultiselection({\n                selections: [],\n                isActive: false,\n            });\n        }\n        setHoveredSelection(null);\n    };\n\n    let handleDownloadSnippet = (snippet) => {\n        const a = document.createElement(\"a\");\n        a.href = snippet.image;\n        a.download = `snippet-${snippet.id}.png`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n    };\n\n    let handleDeleteSnippet = (index) => {\n        onSnippetsChange([\n            ...controlledSnippets.slice(0, index),\n            ...controlledSnippets.slice(index + 1),\n        ]);\n    };\n\n    let item = null;\n    if (loading === true) {\n        debug(\"ui: Loading state\");\n        item = (\n            <Card className=\"p-8 text-center rounded relative\">\n                <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4\"></div>\n                <p>Loading PDF...</p>\n            </Card>\n        );\n    } else if (error !== null) {\n        debug(\"ui: Error state\", { message: error?.message });\n        item = (\n            <Card className=\"p-8 border border-destructive rounded relative\" role=\"alert\">\n                <CardHeader>\n                    <CardTitle>Error</CardTitle>\n                </CardHeader>\n                <CardContent>\n                    <span className=\"block text-muted-foreground\">{error.message}</span>\n                    <pre className=\"pt-4 width-100 overflow-x-auto bg-muted text-muted-foreground p-3 rounded\">\n                        {String(error.stack || '').split(\"\\n\").slice(1).join(\"\\n\")}\n                    </pre>\n                </CardContent>\n            </Card>\n        );\n    } else if (pdfData === null) {\n        debug(\"ui: No PDF loaded\", {\n            pdfPropType: pdf && typeof pdf,\n            pdfPropByteLength: pdf && (pdf.byteLength || pdf.size || pdf.length || null),\n            loading,\n            error: !!error,\n        });\n        item = (\n            <Card className=\"p-8 text-center rounded relative\">\n                No PDF loaded\n            </Card>\n        );\n    } else {\n        item = null;\n    }\n\n    let shouldAllowBookmarkOfPage =\n        contents.find((item) => item.pageNumber === currentPage) !== undefined;\n\n    let tableOfContents = contents.map((item, index) => (\n        <div className=\"flex items-center\" key={item.id}>\n            <Input\n                value={item.title}\n                placeholder={`Enter title for page ${item.pageNumber}`}\n                className=\"border-none shadow-none mr-2\"\n                onChange={(e) =>\n                    handleBookmarkTitleChange(index, e.target.value)\n                }\n            />\n            <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"w-8 h-8 cursor-pointer\"\n                onClick={() => handleOpenPageNumber(item.pageNumber)}\n            >\n                <ArrowUpRight />\n            </Button>\n        </div>\n    ));\n\n    let renderedSnips = controlledSnippets.map((s, index) => {\n        const isCurrentPage = s.pageNumber === currentPage;\n        return (\n            <div\n                key={s.id}\n                className={`p-3 border rounded ${isCurrentPage ? \"bg-accent text-accent-foreground border-border\" : \"border-border\"}`}\n            >\n                <div className=\"mb-2\">\n                    <img\n                        src={s.image}\n                        alt={`Snippet ${index + 1}`}\n                        className=\"w-full h-20 object-contain bg-card border rounded\"\n                    />\n                </div>\n                <div className=\"w-full inline-flex shadow-sm overflow-hidden rounded-md\">\n                    <Button\n                        variant=\"outline\"\n                        size=\"icon\"\n                        onClick={() => handleOpenPageNumber(s.pageNumber)}\n                        className=\"flex-1 rounded-tl-md rounded-bl-md rounded-tr-none rounded-br-none border-r border-border cursor-pointer\"\n                    >\n                        <ArrowUpRight />\n                    </Button>\n                    <Button\n                        variant=\"outline\"\n                        size=\"icon\"\n                        onClick={() => handleDownloadSnippet(s)}\n                        className=\"flex-1 rounded-none border-r border-border cursor-pointer\"\n                    >\n                        <Download />\n                    </Button>\n                    <Button\n                        variant=\"outline\"\n                        size=\"icon\"\n                        onClick={() => handleDeleteSnippet(index)}\n                        className=\"flex-1 rounded-tr-md rounded-br-md rounded-tl-none rounded-bl-none cursor-pointer\"\n                    >\n                        <Trash />\n                    </Button>\n                </div>\n            </div>\n        );\n    });\n\n    return (\n        <div className=\"w-full h-full\">\n            <div className=\"space-y-4\">\n                {item ? (\n                    item\n                ) : (\n                    <div className=\"relative overflow-hidden\">\n                        <div className=\"flex items-center justify-between gap-4 p-2 bg-muted rounded-lg my-4\">\n                            <div className=\"flex items-center gap-2 w-full\">\n                                <Button\n                                    variant=\"ghost\"\n                                    size=\"icon\"\n                                    className=\"size-8 cursor-pointer\"\n                                    onClick={() => handleToggleContents()}\n                                >\n                                    <Menu />\n                                </Button>\n                                {showSnippetsCollection && (\n                                    <Button\n                                        variant=\"ghost\"\n                                        className=\"relative cursor-pointer\"\n                                        onClick={() => handleToggleSnippets()}\n                                    >\n                                        <Scissors className=\"w-6 h-6\" />\n\n                                        <Badge\n                                            variant=\"default\"\n                                            className=\"absolute top-0 left-full -translate-x-full h-5 min-w-5 rounded-full px-1 font-mono tabular-nums text-xs\"\n                                        >\n                                            {controlledSnippets.length}\n                                        </Badge>\n                                    </Button>\n                                )}\n                                <div className=\"grow\"></div>\n                                <Slider\n                                    defaultValue={[150]}\n                                    max={300}\n                                    min={50}\n                                    step={10}\n                                    className=\"w-[150px]\"\n                                    onValueChange={(val) =>\n                                        handleScaleChange(val[0])\n                                    }\n                                />\n                                <Button\n                                    variant=\"ghost\"\n                                    size=\"icon\"\n                                    className=\"size-8 cursor-pointer\"\n                                    onClick={() => handlePreviousPage()}\n                                >\n                                    <ChevronLeft />\n                                </Button>\n                                <span className=\"text-sm fit-content\">\n                                    Page{\" \"}\n                                    <Input\n                                        className=\"inline border-none shadow-none w-[fit-content] mx-2\"\n                                        value={currentPage}\n                                        type=\"number\"\n                                        min={1}\n                                        max={totalPages}\n                                        onChange={(e) =>\n                                            handleOpenPageNumber(e.target.value)\n                                        }\n                                    />{\" \"}\n                                    of {totalPages}\n                                </span>\n                                <Button\n                                    variant=\"ghost\"\n                                    size=\"icon\"\n                                    className=\"size-8 cursor-pointer\"\n                                    onClick={() => handleNextPage()}\n                                >\n                                    <ChevronRight />\n                                </Button>\n                            </div>\n                        </div>\n                        <div className=\"flex-1 overflow-hidden\">\n                            <div className=\"overflow-auto min-h-[800px] h-full max-h-[100vh] border rounded\">\n                                <div className=\"relative w-fit\">\n                                    <canvas ref={canvasRef} className=\"block\" />\n                                    <canvas\n                                        ref={overlayRef}\n                                        className=\"absolute top-0 left-0 w-full h-full cursor-crosshair touch-none\"\n                                        onPointerDown={(e) =>\n                                            handlePointerDown(e)\n                                        }\n                                        onPointerMove={(e) =>\n                                            handlePointerMove(e)\n                                        }\n                                        onPointerUp={(e) => handlePointerUp(e)}\n                                        onPointerLeave={(e) =>\n                                            handlePointerLeave(e)\n                                        }\n                                        onPointerCancel={(e) =>\n                                            handlePointerCancel(e)\n                                        }\n                                    />\n                                </div>\n                            </div>\n                            <Card\n                                className={`h-[calc(100%-6em)] w-[40%] absolute bottom-2 left-2 ${isContentsOpen ? \"translate-x-0\" : \"-translate-x-[calc(100%+2em)]\"} transition-transform duration-300`}\n                            >\n                                <CardHeader className=\"flex items-center\">\n                                    <CardTitle className=\"grow\">\n                                        Table of Contents\n                                    </CardTitle>\n                                    <Button\n                                        className=\"cursor-pointer\"\n                                        variant=\"ghost\"\n                                        size=\"icon\"\n                                        onClick={() => {\n                                            const levelStr = prompt(\n                                                \"How many levels of the outline should be extracted?\",\n                                                \"1\",\n                                            );\n                                            const level = parseInt(levelStr);\n                                            if (!isNaN(level) && level > 0) {\n                                                handleExtractOutline(level);\n                                            }\n                                        }}\n                                    >\n                                        <GitPullRequestArrow />\n                                    </Button>\n                                    {shouldAllowBookmarkOfPage === true ? (\n                                        <Button\n                                            className=\"cursor-pointer\"\n                                            variant=\"ghost\"\n                                            size=\"icon\"\n                                            onClick={() =>\n                                                handleRemoveBookmark(\n                                                    currentPage,\n                                                )\n                                            }\n                                        >\n                                            <BookmarkX />\n                                        </Button>\n                                    ) : (\n                                        <Button\n                                            className=\"cursor-pointer\"\n                                            variant=\"ghost\"\n                                            size=\"icon\"\n                                            onClick={() =>\n                                                handleAddBookmark(currentPage)\n                                            }\n                                        >\n                                            <Bookmark />\n                                        </Button>\n                                    )}\n                                </CardHeader>\n                                <CardContent className=\"overflow-auto\">\n                                    {tableOfContents}\n                                </CardContent>\n                            </Card>\n                            {showSnippetsCollection && (\n                                <Card\n                                    className={`h-[calc(100%-6em)] w-[40%] absolute bottom-2 left-2 ${isSnippetsOpen ? \"translate-x-0\" : \"-translate-x-[calc(100%+2em)]\"} transition-transform duration-300`}\n                                >\n                                    <CardHeader className=\"flex items-center\">\n                                        <CardTitle>Snippets</CardTitle>\n                                    </CardHeader>\n                                    <CardContent className=\"overflow-auto space-y-2\">\n                                        {renderedSnips}\n                                    </CardContent>\n                                </Card>\n                            )}\n                        </div>\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n}\n"
        },
        {
            "path": "registry/new-york/boxcutter/utils/helpers.ts",
            "type": "registry:lib",
            "target": "lib/boxcutter/utils/helpers.ts",
            "content": "// @ts-nocheck\n\nexport function deepEquals(...items) {\n    let equal = (a, b) => {\n        if (a === b) return true;\n\n        if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n            if (a.constructor !== b.constructor) return false;\n            var length, i, keys;\n            if (Array.isArray(a)) {\n                length = a.length;\n                if (length != b.length) return false;\n                for (i = length; i-- !== 0; )\n                    if (!equal(a[i], b[i])) return false;\n                return true;\n            }\n\n            if (a instanceof Map && b instanceof Map) {\n                if (a.size !== b.size) return false;\n                for (i of a.entries()) if (!b.has(i[0])) return false;\n                for (i of a.entries())\n                    if (!equal(i[1], b.get(i[0]))) return false;\n                return true;\n            }\n\n            if (a instanceof Set && b instanceof Set) {\n                if (a.size !== b.size) return false;\n                for (i of a.entries()) if (!b.has(i[0])) return false;\n                return true;\n            }\n\n            if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n                length = a.length;\n                if (length != b.length) return false;\n                for (i = length; i-- !== 0; ) if (a[i] !== b[i]) return false;\n                return true;\n            }\n\n            if (a.constructor === RegExp)\n                return a.source === b.source && a.flags === b.flags;\n\n            if (a.valueOf !== Object.prototype.valueOf)\n                return a.valueOf() === b.valueOf();\n\n            if (a.toString !== Object.prototype.toString)\n                return a.toString() === b.toString();\n\n            keys = Object.keys(a);\n            length = keys.length;\n            if (length !== Object.keys(b).length) return false;\n            for (i = length; i-- !== 0; )\n                if (!Object.prototype.hasOwnProperty.call(b, keys[i]))\n                    return false;\n            for (i = length; i-- !== 0; ) {\n                var key = keys[i];\n\n                if (key === \"_owner\" && a.$$typeof) {\n                    continue;\n                }\n                if (!equal(a[key], b[key])) return false;\n            }\n            return true;\n        }\n\n        // true if both NaN, false otherwise\n        return a !== a && b !== b;\n    };\n\n    if (items.length === 0) return false;\n\n    let first = items[0];\n    for (let i = 1; i < items.length; i++) {\n        if (!equal(first, items[i])) return false;\n    }\n\n    return true;\n}\n\nexport function createPreviewUrl(snippet) {\n    const blob = new Blob([snippet.imageData], { type: \"image/png\" });\n    return URL.createObjectURL(blob);\n}\n"
        },
        {
            "path": "registry/new-york/boxcutter/utils/pdfjs.ts",
            "type": "registry:lib",
            "target": "lib/boxcutter/utils/pdfjs.ts",
            "content": "// @ts-nocheck\n\nimport * as pdfjsLib from \"pdfjs-dist\";\n\n// Note: We no longer create a Worker via a bundled asset here because\n// some consumers (e.g., Next.js/webpack on the server) attempt to\n// statically resolve `new URL(..., import.meta.url)` and fail.\n//\n// Consumers should set the worker explicitly in client code, e.g.:\n//   - Provide a module worker URL in your public assets and call\n//       pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.mjs\";\n//     or create a Worker and pass the port:\n//       pdfjsLib.GlobalWorkerOptions.workerPort = new Worker(\n//         \"/pdf.worker.min.mjs\", { type: \"module\" }\n//       );\n//\n// We still export `pdfjsLib` so BoxCutter can use pdfjs when initialized\n// and allow applications to configure the worker as they prefer.\n\nexport { pdfjsLib };\n\n// Optional helper for apps that want a convenience initializer without\n// forcing bundlers to resolve a specific asset during build.\nexport function initPdfjsWorker({ url, port } = {}) {\n    if (typeof window === \"undefined\") return;\n    try {\n        if (port) {\n            pdfjsLib.GlobalWorkerOptions.workerPort = port;\n            return port;\n        }\n        if (url) {\n            const worker = new Worker(\n                /* webpackIgnore: true */ /* @vite-ignore */ url,\n                { type: \"module\" },\n            );\n            pdfjsLib.GlobalWorkerOptions.workerPort = worker;\n            return worker;\n        }\n        if (typeof console !== \"undefined\") {\n            console.warn(\"[BoxCutter] initPdfjsWorker called without url/port; no worker configured.\");\n        }\n    } catch (e) {\n        if (typeof console !== \"undefined\") {\n            console.warn(\"[BoxCutter] Failed to initialize pdfjs worker; pdfjs may use a fallback.\", e);\n        }\n    }\n    return null;\n}\n"
        }
    ],
    "docs": "Import the component from '@/components/boxcutter', pull helpers from '@/lib/boxcutter/utils', include '@tamatashwin/boxcutter/styles.css' if you rely on the package tokens, and call initPdfjsWorker to point pdf.js at a worker URL before rendering."
}